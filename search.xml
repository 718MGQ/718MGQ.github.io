<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021届校招内推分享</title>
      <link href="/2020/09/08/java-push/"/>
      <url>/2020/09/08/java-push/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分享几个2021届校招内推信息，持续更新</p></blockquote><ul><li>快手21届校招内推，直接申请投递即可<br><a href="https://campus.kuaishou.cn/recruit/campus/e/#/campus/jobs?internalPerson=TkttKFlRkBS2hYdhonMHuw%3D%3D&amp;recruitSubProjectCode=2021qiuzhao" target="_blank" rel="noopener">https://campus.kuaishou.cn/recruit/campus/e/#/campus/jobs?internalPerson=TkttKFlRkBS2hYdhonMHuw%3D%3D&amp;recruitSubProjectCode=2021qiuzhao</a><a id="more"></a></li></ul><hr><ul><li>字节跳动内推，直接申请<img src="/images/tiktok.jpg" width="30%" height="30%"></li></ul><hr><ul><li>贝壳Java开发内推，岗位信息如下，内推添加微信发送简历 微信：m1159950461(添加请实名说明原因)<br>  <a href="http://campus.ke.com/zpdetail/190239336?k=java&amp;r=-1&amp;d=&amp;c=&amp;p=" target="_blank" rel="noopener">http://campus.ke.com/zpdetail/190239336?k=java&amp;r=-1&amp;d=&amp;c=&amp;p=</a></li></ul><hr><ul><li>滴滴内推<img src="/images/didi.jpg" width="30%" height="30%"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 内推 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="/2020/08/11/alg-fibonacci/"/>
      <url>/2020/08/11/alg-fibonacci/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述-leetcode-70"><a href="#题目描述-leetcode-70" class="headerlink" title="题目描述(leetcode 70)"></a>题目描述(leetcode 70)</h3><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p></blockquote><pre><code>不建议使用递归，当n很大的时候，递归会超时！</code></pre><a id="more"></a><h4 id="解法一：流处理"><a href="#解法一：流处理" class="headerlink" title="解法一：流处理"></a>解法一：流处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res =  Stream</span><br><span class="line">                .iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, f -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;f[<span class="number">1</span>], f[<span class="number">0</span>] + f[<span class="number">1</span>]&#125;)</span><br><span class="line">                .limit(n)</span><br><span class="line">                .mapToInt(f -&gt; f[<span class="number">0</span>])</span><br><span class="line">                .toArray();</span><br><span class="line">        <span class="keyword">return</span> res[res.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = first + second;</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络分层</title>
      <link href="/2020/06/20/net-OSI/"/>
      <url>/2020/06/20/net-OSI/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍一下两种分层模型：OSI网络分层和TCP/IP网络分层。</p><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><blockquote><p>OSI模型一共分为七层，由上至下分别是：</p></blockquote><ul><li>应用层</li><li>表达层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层<a id="more"></a></li></ul><h4 id="应用层-Application"><a href="#应用层-Application" class="headerlink" title="应用层(Application)"></a>应用层(Application)</h4><pre><code>应用层的协议一般有：HTTP、FTP、DNS等，这一层是最接近用户的一层。</code></pre><h4 id="表达层-Presentation"><a href="#表达层-Presentation" class="headerlink" title="表达层(Presentation)"></a>表达层(Presentation)</h4><pre><code>该层的主要功能：转换，压缩和加密，常见的加密协议为SSL。</code></pre><h4 id="会话层-Session"><a href="#会话层-Session" class="headerlink" title="会话层(Session)"></a>会话层(Session)</h4><pre><code>我们可以把会话层理解为两个应用进程之间的逻辑连接，同时会话层还负责了管理和确定传输模式计算机传输数据有三种模式：单向、半双工、全双工</code></pre><h4 id="传输层-Transport"><a href="#传输层-Transport" class="headerlink" title="传输层(Transport)"></a>传输层(Transport)</h4><pre><code>传输层就是表面意思传输了，端到端，主机到主机的传输这一层最主要的就是TCP、UDP啦，包括三次握手、四次挥手是必须要会的</code></pre><h4 id="网络层-Network"><a href="#网络层-Network" class="headerlink" title="网络层(Network)"></a>网络层(Network)</h4><pre><code>网络层需要提供三个最基本的功能：地址、路由、分段和重组网络层上最重要的协议IP（Internet Protocol），就是为了这些功能而设计的。目前有IPv4和IPv6两个版本。</code></pre><h4 id="数据链路层-Data-Link"><a href="#数据链路层-Data-Link" class="headerlink" title="数据链路层(Data Link)"></a>数据链路层(Data Link)</h4><pre><code>数据链路层又分为两个子层：逻辑链路控制层(Logical Link Control)和介质访问控制层(Media Access Control)数据链路层就是关心如何把数据从一个设备发送到另一个设备</code></pre><h4 id="物理层-Physical"><a href="#物理层-Physical" class="headerlink" title="物理层(Physical)"></a>物理层(Physical)</h4><pre><code>物理层位于OSI的底层，所有其他层的数据最终都必须经由物理层才能发送出去。</code></pre><hr><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><pre><code>TCP/IP模型分为四层：应用层（Application）、传输层（Host-to-Host Transport）、互联网层(Internet)、网络接口层(Network Interface)。</code></pre><p>在TCP/IP模型中并不包含物理层。另外，两个重要的协议ARP（Address Resolution Protocol，地址解析协议）和RARP（Reverse Address Resolution Protocol，反向地址转换协议），在OSI模型中一般被认为是在位于第二层数据链路层和第三层网络层之间，而在TCP/IP模型中则位于网络接口层。(此段转载自掘金：<a href="https://juejin.im/post/5a98e1f7f265da237410694e" target="_blank" rel="noopener">https://juejin.im/post/5a98e1f7f265da237410694e</a> 作者：MinGRn）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程通信</title>
      <link href="/2020/06/20/net-IPC/"/>
      <url>/2020/06/20/net-IPC/</url>
      
        <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><hr><blockquote><p>我们在面试中常常被问到进程通信的方式有哪些，感觉与我们平时的开发工作没有关系，其实我们也是一直在用它</p></blockquote><h4 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h4><hr><blockquote><p>1、管道（pipe）<br>        管道又分为无名管道（即匿名管道）和有名管道<br>        其实我们平时经常用到无名管道，在Linux命令中”|”就是无名管道的使用，<br>        他将一个进程的输出传入到另一个进程中，比如：<br>        <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> xxxlog | <span class="keyword">grep</span> <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure><br>        有名管道可以通过 mkfifo <pipename> 命令创建<br>        <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mkfifo pipe</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>2、消息队列</p></blockquote><a id="more"></a><pre><code>注意，这个消息队列不是我们常说的MQ，Kafka、RocketMQ、RabbitMQ等</code></pre><blockquote><p>消息队列提供了一种从一个进程发送到另一个进程的数据块的方法，<br>但是像有名管道一样，消息队列的数据最大长度是有限的，这个也是这种进程通信的一个缺点<br>再多的，我也不清楚了，，，请各路神仙指教了</p></blockquote><blockquote><p>3、共享内存<br>        共享内存的实质是每个进程都有自己的一个虚拟空间，而不是真实的物理空间，每个线程将自己的虚拟的内存空间指向真实的物理空间，这样其中有一部分的内存空间指向的就是同一块物理空间，这就完成了内存共享的机制；</p></blockquote><blockquote><p>4、信号量<br>        我们回想内存共享的缺点是什么？就是当多个进程竞争资源怎么办，就类似于多线程的并发问题。<br>        这个时候信号量就派上用场了。<br>        信号量本身是个计数器，用来控制进程之间的互斥和同步，通过信号量的值来控制进程对内存的访问，从而解决了多个进程竞争内存的问题。</p></blockquote><blockquote><p>5、Socket<br>        套接字就是我们现在在使用的进程通信方式，我们在使用通信工具比如QQ、微信APP和客户端之间的通信就是使用Socket进行通信的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>进程之间的通信方式有几种</code></pre><ul><li>管道</li><li>消息队列</li><li>内存共享</li><li>信号量</li><li>Socket</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java面试图谱</title>
      <link href="/2020/06/16/java-interview/"/>
      <url>/2020/06/16/java-interview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单列出Java面试图谱，仅供参考！</p></blockquote><img src="/images/Java开发知识储备.png" width="90%"><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Java面试图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试 </tag>
            
            <tag> 图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三次握手、四次挥手</title>
      <link href="/2020/06/14/net-three-and-four/"/>
      <url>/2020/06/14/net-three-and-four/</url>
      
        <content type="html"><![CDATA[<blockquote><h6 id="过程如下图"><a href="#过程如下图" class="headerlink" title="过程如下图"></a>过程如下图</h6></blockquote><img src="/images/threeAndFour.png" width="80%"><a id="more"></a><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，客户端和服务器端是相对的概念，本文我们以客户端向服务器端发送为例。</p></blockquote><blockquote><p><strong>第一次握手：客户端向服务器端发送一个SYN报文，报文中包含了一个动态生成的序列号i（至于为什么动态生成可以自己想想），这时，客户端处于SYN_SEND状态（打开一个连接），表示已向服务器发送了连接请求；</strong></p></blockquote><blockquote><p><strong>第二次握手：服务器端接收到连接请求，认为可以建起连接，回发一个ACK确认报文，内容将序列号i+1,同时，生成一个序列号j，发送一个SYN报文，内容为序列号j，服务器端处于SYN_REVD状态（连接请求已到达，等待确认），表示等待客户端确认连接；</strong></p></blockquote><blockquote><p><strong>第三次握手：客户端接收到服务器端的反馈，立马发送一个ACK报文，内容为j+1，便是确认连接，这时客户端状态为establish(正常传输状态)</strong></p></blockquote><blockquote><p><strong>服务器端接收到ACK报文后，连接建立完成。</strong></p></blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>依然以客户端主动发起断开连接为例。</p><blockquote><p><strong>第一次挥手：客户端主动发起断开请求，动态生成一个序列号M，向服务器发送一个FIN报文，此时，客户端处于FIN_WAIT1状态；</strong></p></blockquote><blockquote><p><strong>第二次挥手： 服务器端收到客户端的断开请求，发送确认报文ACK(M+1)，告诉客户端，我知道了，等我处理完这波数据，此时服务器状态为CLOSE_WAIT;</strong></p></blockquote><blockquote><p><strong>第三次挥手： 等服务器处理完，准备要断开连接了，向客户端发送一个FIN报文，伴有动态生成的序列号N，此时服务器状态LAST_ACK;</strong></p></blockquote><blockquote><p><strong>第四次挥手： 客户端收到服务器发来的断开连接报文，则回复一个ACK报文N+1，表示我确认断开连接，这时客户端处于</strong> <strong><em>TIME_WAIT状态</em></strong> <strong>，很关键的状态，面试高频出现；</strong></p></blockquote><blockquote><p><strong>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</strong></p></blockquote><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><ol><li><p><strong>TIME_WAIT状态</strong></p><pre><code>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功收到 ACK 报文，此时处于 CLOSED 状态。</code></pre></li><li><p><strong>半连接</strong><br>  <strong>即发送了SYN包还未收到ACK确认包的连接状态为半连接状态，还未完成三次握手TCP连接。</strong></p><pre><code>半连接队列:在三次握手协议中，服务器维护一个半连接队列；该队列为每个客户端的SYN包(SYN=i)开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于SYN_ RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</code></pre></li><li><p><strong>DOS攻击</strong></p><pre><code>因为服务器会维护一个半连接的队列，那如果我们向服务器发送大量伪造的无效的半连接请求，便会消耗cpu和内存，当伪造的SYN包长时间占用半连接队列，正常的SYN请求遍会被抛弃，服务器便面临着网络阻塞甚至系统瘫痪的风险，这也是比较常见的一种DOS攻击方式。</code></pre></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> internet </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOS攻击</title>
      <link href="/2020/06/13/net-dos/"/>
      <url>/2020/06/13/net-dos/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是DOS攻击"><a href="#什么是DOS攻击" class="headerlink" title="什么是DOS攻击"></a><a href="https://baike.baidu.com/item/dos%E6%94%BB%E5%87%BB/3792374?fr=aladdin" target="_blank" rel="noopener">什么是DOS攻击</a></h3><blockquote><p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。</p></blockquote><a id="more"></a><blockquote><p>说白了就是机器单挑，比谁的机器性能好、速度快<br>但是这种方式已经很远古了，毕竟计算机在迅速发展，性能也在不断提升，比如一个黑客用自己的机器，每秒钟发送10个伪装的数据包，但是被攻击的网站背后有十几台机器，每秒可以接受成百上千的数据，这时候攻击就无济于事了，反而会偷鸡不成蚀把米，自己的机器很可能会宕机。</p></blockquote><h3 id="什么是DDOS"><a href="#什么是DDOS" class="headerlink" title="什么是DDOS"></a>什么是DDOS</h3><blockquote><p>分布式拒绝服务攻击，简单说就是群殴，技术在发展，黑客也在学习，ddos就是黑客利用多台 “<strong>肉鸡</strong>”（就是可以被远程控制的多台机器），对某一网站进行攻击，可能每台机器每秒发送10个数据包，成群的 <strong>肉鸡</strong> 便可以每秒钟发出成百上千的伪装的攻击数据包，这个时候就很难抵挡了。到目前为止，防止这种攻击还是很吃力的。</p></blockquote><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><blockquote><p>我们了解了什么事dos，什么事ddos, 那么他们是怎么攻击的呢，原理是什么？？？<br>按照原理，简单来说以下几种：<br> 1.比如IP为1.1.1.1的地址是合法用户，黑客可以把自己的IP伪装成1.1.1.1，向服务器发送一个带有RST位的TCP数据段，服务器接收到之后认为该链接有错误，便会清除缓冲区建立好的连接，这时合法用户再去访问只能重新建立连接。<br> 2.向服务器发送大量的毫无用处的UDP数据包，占满带宽，导致网络可用带宽占满，最终导致服务器瘫痪。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 网络 </tag>
            
            <tag> dos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="/2020/06/13/alg-reverse-integer/"/>
      <url>/2020/06/13/alg-reverse-integer/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">力扣</a></p><blockquote><p>Given a 32-bit signed integer, reverse digits of an integer.<br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p></blockquote><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>整数反转当然容易，但是要注意的是32位，溢出问题怎么处理？这里提供三种方式：<strong>String</strong>、<strong>Long</strong>、<strong>Int</strong>(<strong><em>推荐</em></strong>)</p></blockquote><h3 id="方法一：String"><a href="#方法一：String" class="headerlink" title="方法一：String"></a>方法一：String</h3><blockquote><p>利用StringBuffer 的reverse()方法，进行逆置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非负数标记，false为负数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果x为-2147483648，-x超过Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">if</span>(x == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为负数，加-号</span></span><br><span class="line">        String str = flag ? <span class="keyword">new</span> StringBuffer(String.valueOf(x)).reverse().toString() : <span class="string">"-"</span> + <span class="keyword">new</span> StringBuffer(String.valueOf(x)).reverse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(Long.valueOf(str) &gt; Integer.MAX_VALUE || Long.valueOf(str) &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：Long"><a href="#方法二：Long" class="headerlink" title="方法二：Long"></a>方法二：Long</h3><blockquote><p>用Long值存下,对long值进行反转，最后再判断范围</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Long result = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三：Int"><a href="#方法三：Int" class="headerlink" title="方法三：Int"></a>方法三：Int</h3><blockquote><p>以上两种方法都可以很好的解决这个问题，但是我们反思一下，或者我们来强制的加个条件，如果在运行中只能使用32位的整数，该怎么办呢？虽然现在的内存已经不宝贵了，但是我们还是要爱惜一下嘛～<br>那么更好的方法来了，这个题的关键就是输入值x在反转的过程中可能会超过int值的范围，那我们在循环的取数的时候，每次去判断下一个值是否会超过int的范围，这不就OK了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">            <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE / <span class="number">10</span> || (result == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result &lt; Integer.MIN_VALUE / <span class="number">10</span> || (result == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表逆置</title>
      <link href="/2020/06/12/alg-reverse-list/"/>
      <url>/2020/06/12/alg-reverse-list/</url>
      
        <content type="html"><![CDATA[<h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><blockquote><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p></blockquote><p>示例：</p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><a id="more"></a><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><blockquote><p>头插法简单明了 <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">code</a></p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(int x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode getReverseList(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//定义一个空的头节点</span></span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">List</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//定一个临时指针，指向下一个节点</span></span><br><span class="line">            ListNode nextNode = head.next;</span><br><span class="line">            <span class="comment">//断开当前节点与下一个节点连接，并接到新链表的前面</span></span><br><span class="line">            head.next = <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">            <span class="comment">//当前节点插入到头节点之后（头插法）</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">List</span>.next = head;</span><br><span class="line">            <span class="comment">//当前节点向后移</span></span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分法查找</title>
      <link href="/2020/06/07/alg-binary/"/>
      <url>/2020/06/07/alg-binary/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><hr><blockquote><p>二分法查找：又称折半查找。适用于有序数据集合的目标值查找。</p></blockquote><pre><code>二分法思想：假设有一个按升序排好序的数列data，查找目标值target，过程如下：1.将数列进行折半，判断data[mid]是否等于target, 相等则返回index, 否则，判断中间值和target大小；2.若 target &gt; data[mid]，将data右一半执行第一步，否则，将data左一半执行第一步；3.返回index</code></pre><a id="more"></a><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><hr><p>废话不多说，上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//定义一个中间值索引</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">                <span class="comment">//查到目标值，直接返回索引值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束，未找到target，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><blockquote><p>假如数列中出现了重复项，那我们查到的index便不确定，那如何在重复项得到最小的一个位置呢？</p></blockquote><h4 id="二分查找-顺序查找"><a href="#二分查找-顺序查找" class="headerlink" title="二分查找 + 顺序查找"></a>二分查找 + 顺序查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRepeatIndex</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这里做一改变</span></span><br><span class="line">            <span class="comment">//如果定位到目标值，不立即返回，顺序查找到最靠前的一个</span></span><br><span class="line">            <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(data[mid] != target) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mid --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环时多-1，返回时加上</span></span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(data[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二分法到底"><a href="#二分法到底" class="headerlink" title="二分法到底"></a>二分法到底</h4><blockquote><p>可能大多数考虑到上述的情况就结束了，仔细想想，还可不可以更快一点儿呢，回答是肯定的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRepeatIndex</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果数组空直接返回，防止数组越界</span></span><br><span class="line">        <span class="keyword">if</span>(data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//'&lt;'不是'&lt;=',如果等于会出现死循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//关键部位！！！</span></span><br><span class="line">            <span class="comment">//保持要查到的值始终是最小索引的，二分查比顺序查要快</span></span><br><span class="line">            <span class="keyword">if</span>(data[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(data[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> algorithm </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2020/05/20/Java/"/>
      <url>/2020/05/20/Java/</url>
      
        <content type="html"><![CDATA[<h4 id="volatile修饰"><a href="#volatile修饰" class="headerlink" title="volatile修饰"></a>volatile修饰</h4><blockquote><p>变量声明了volatile后，跳过cpu cache步骤，jvm保证每次直接从内存中读取变量</p></blockquote><ul><li>volatile声明的变量所有线程可见，即当修改一个变量值会立即更新直接更新内存，读取是也直接从内存中刷新读取</li><li>volatile声明的变量禁止指令重排序优化</li></ul><h4 id="volatile性能"><a href="#volatile性能" class="headerlink" title="volatile性能"></a>volatile性能</h4><blockquote><p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
