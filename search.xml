<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二分法查找</title>
    <url>/2020/06/07/alg-binary/</url>
    <content><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><hr>
<blockquote>
<p>二分法查找：又称折半查找。适用于有序数据集合的目标值查找。</p>
</blockquote>
<pre><code>二分法思想：假设有一个按升序排好序的数列data，查找目标值target，过程如下：
1.将数列进行折半，判断data[mid]是否等于target, 相等则返回index, 否则，判断中间值和target大小；
2.若 target &gt; data[mid]，将data右一半执行第一步，否则，将data左一半执行第一步；
3.返回index</code></pre><a id="more"></a>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><hr>
<p>废话不多说，上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//定义一个中间值索引</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">                <span class="comment">//查到目标值，直接返回索引值</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束，未找到target，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><blockquote>
<p>假如数列中出现了重复项，那我们查到的index便不确定，那如何在重复项得到最小的一个位置呢？</p>
</blockquote>
<h4 id="二分查找-顺序查找"><a href="#二分查找-顺序查找" class="headerlink" title="二分查找 + 顺序查找"></a>二分查找 + 顺序查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRepeatIndex</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//这里做一改变</span></span><br><span class="line">            <span class="comment">//如果定位到目标值，不立即返回，顺序查找到最靠前的一个</span></span><br><span class="line">            <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (mid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(data[mid] != target) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mid --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环时多-1，返回时加上</span></span><br><span class="line">                <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的右半部分</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//目标值在数列的左半部分</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(data[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分法到底"><a href="#二分法到底" class="headerlink" title="二分法到底"></a>二分法到底</h4><blockquote>
<p>可能大多数考虑到上述的情况就结束了，仔细想想，还可不可以更快一点儿呢，回答是肯定的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRepeatIndex</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = data.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果数组空直接返回，防止数组越界</span></span><br><span class="line">        <span class="keyword">if</span>(data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//'&lt;'不是'&lt;=',如果等于会出现死循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//关键部位！！！</span></span><br><span class="line">            <span class="comment">//保持要查到的值始终是最小索引的，二分查比顺序查要快</span></span><br><span class="line">            <span class="keyword">if</span>(data[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果可以找到，left则为对应的索引值</span></span><br><span class="line">        <span class="keyword">if</span>(data[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2020/05/20/Java/</url>
    <content><![CDATA[<h4 id="volatile修饰"><a href="#volatile修饰" class="headerlink" title="volatile修饰"></a>volatile修饰</h4><blockquote>
<p>变量声明了volatile后，跳过cpu cache步骤，jvm保证每次直接从内存中读取变量</p>
</blockquote>
<ul>
<li>volatile声明的变量所有线程可见，即当修改一个变量值会立即更新直接更新内存，读取是也直接从内存中刷新读取</li>
<li>volatile声明的变量禁止指令重排序优化</li>
</ul>
<h4 id="volatile性能"><a href="#volatile性能" class="headerlink" title="volatile性能"></a>volatile性能</h4><blockquote>
<p>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2020/08/11/alg-fibonacci/</url>
    <content><![CDATA[<h3 id="题目描述-leetcode-70"><a href="#题目描述-leetcode-70" class="headerlink" title="题目描述(leetcode 70)"></a>题目描述(leetcode 70)</h3><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>注意：给定 n 是一个正整数。</p>
</blockquote>
<pre><code>不建议使用递归，当n很大的时候，递归会超时！</code></pre><a id="more"></a>
<h4 id="解法一：流处理"><a href="#解法一：流处理" class="headerlink" title="解法一：流处理"></a>解法一：流处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res =  Stream</span><br><span class="line">                .iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, f -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;f[<span class="number">1</span>], f[<span class="number">0</span>] + f[<span class="number">1</span>]&#125;)</span><br><span class="line">                .limit(n)</span><br><span class="line">                .mapToInt(f -&gt; f[<span class="number">0</span>])</span><br><span class="line">                .toArray();</span><br><span class="line">        <span class="keyword">return</span> res[res.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = second;</span><br><span class="line">            second = first + second;</span><br><span class="line">            first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/2020/06/13/alg-reverse-integer/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">力扣</a></p>
<blockquote>
<p>Given a 32-bit signed integer, reverse digits of an integer.<br>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
</blockquote>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>整数反转当然容易，但是要注意的是32位，溢出问题怎么处理？这里提供三种方式：<strong>String</strong>、<strong>Long</strong>、<strong>Int</strong>(<strong><em>推荐</em></strong>)</p>
</blockquote>
<h3 id="方法一：String"><a href="#方法一：String" class="headerlink" title="方法一：String"></a>方法一：String</h3><blockquote>
<p>利用StringBuffer 的reverse()方法，进行逆置</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非负数标记，false为负数</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果x为-2147483648，-x超过Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">if</span>(x == Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            x = -x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为负数，加-号</span></span><br><span class="line">        String str = flag ? <span class="keyword">new</span> StringBuffer(String.valueOf(x)).reverse().toString() : <span class="string">"-"</span> + <span class="keyword">new</span> StringBuffer(String.valueOf(x)).reverse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(Long.valueOf(str) &gt; Integer.MAX_VALUE || Long.valueOf(str) &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：Long"><a href="#方法二：Long" class="headerlink" title="方法二：Long"></a>方法二：Long</h3><blockquote>
<p>用Long值存下,对long值进行反转，最后再判断范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        Long result = <span class="number">0L</span>;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            result = result * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">        <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：Int"><a href="#方法三：Int" class="headerlink" title="方法三：Int"></a>方法三：Int</h3><blockquote>
<p>以上两种方法都可以很好的解决这个问题，但是我们反思一下，或者我们来强制的加个条件，如果在运行中只能使用32位的整数，该怎么办呢？虽然现在的内存已经不宝贵了，但是我们还是要爱惜一下嘛～<br>那么更好的方法来了，这个题的关键就是输入值x在反转的过程中可能会超过int值的范围，那我们在循环的取数的时候，每次去判断下一个值是否会超过int的范围，这不就OK了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//不断的取x的最后一位，加到result后面</span></span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否超过Integer值范围</span></span><br><span class="line">            <span class="keyword">if</span>(result &gt; Integer.MAX_VALUE / <span class="number">10</span> || (result == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result &lt; Integer.MIN_VALUE / <span class="number">10</span> || (result == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; Integer.MIN_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>链表逆置</title>
    <url>/2020/06/12/alg-reverse-list/</url>
    <content><![CDATA[<h3 id="链表逆置"><a href="#链表逆置" class="headerlink" title="链表逆置"></a>链表逆置</h3><blockquote>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
</blockquote>
<a id="more"></a>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><blockquote>
<p>头插法简单明了 <a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">code</a></p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(int x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode getReverseList(ListNode head) &#123;</span><br><span class="line">        <span class="comment">//定义一个空的头节点</span></span><br><span class="line">        ListNode <span class="keyword">new</span><span class="type">List</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//定一个临时指针，指向下一个节点</span></span><br><span class="line">            ListNode nextNode = head.next;</span><br><span class="line">            <span class="comment">//断开当前节点与下一个节点连接，并接到新链表的前面</span></span><br><span class="line">            head.next = <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">            <span class="comment">//当前节点插入到头节点之后（头插法）</span></span><br><span class="line">            <span class="keyword">new</span><span class="type">List</span>.next = head;</span><br><span class="line">            <span class="comment">//当前节点向后移</span></span><br><span class="line">            head = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">List</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>algorithm</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2020/06/20/net-IPC/</url>
    <content><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><hr>
<blockquote>
<p>我们在面试中常常被问到进程通信的方式有哪些，感觉与我们平时的开发工作没有关系，其实我们也是一直在用它</p>
</blockquote>
<h4 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h4><hr>
<blockquote>
<p>1、管道（pipe）<br>        管道又分为无名管道（即匿名管道）和有名管道<br>        其实我们平时经常用到无名管道，在Linux命令中”|”就是无名管道的使用，<br>        他将一个进程的输出传入到另一个进程中，比如：<br>        <figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> xxxlog | <span class="keyword">grep</span> <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure><br>        有名管道可以通过 mkfifo <pipename> 命令创建<br>        <figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mkfifo pipe</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>2、消息队列</p>
</blockquote>
<a id="more"></a>
<pre><code>注意，这个消息队列不是我们常说的MQ，Kafka、RocketMQ、RabbitMQ等</code></pre><blockquote>
<p>消息队列提供了一种从一个进程发送到另一个进程的数据块的方法，<br>但是像有名管道一样，消息队列的数据最大长度是有限的，这个也是这种进程通信的一个缺点<br>再多的，我也不清楚了，，，请各路神仙指教了</p>
</blockquote>
<blockquote>
<p>3、共享内存<br>        共享内存的实质是每个进程都有自己的一个虚拟空间，而不是真实的物理空间，每个线程将自己的虚拟的内存空间指向真实的物理空间，这样其中有一部分的内存空间指向的就是同一块物理空间，这就完成了内存共享的机制；</p>
</blockquote>
<blockquote>
<p>4、信号量<br>        我们回想内存共享的缺点是什么？就是当多个进程竞争资源怎么办，就类似于多线程的并发问题。<br>        这个时候信号量就派上用场了。<br>        信号量本身是个计数器，用来控制进程之间的互斥和同步，通过信号量的值来控制进程对内存的访问，从而解决了多个进程竞争内存的问题。</p>
</blockquote>
<blockquote>
<p>5、Socket<br>        套接字就是我们现在在使用的进程通信方式，我们在使用通信工具比如QQ、微信APP和客户端之间的通信就是使用Socket进行通信的。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>进程之间的通信方式有几种</code></pre><ul>
<li>管道</li>
<li>消息队列</li>
<li>内存共享</li>
<li>信号量</li>
<li>Socket</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title>java面试图谱</title>
    <url>/2020/06/16/java-interview/</url>
    <content><![CDATA[<blockquote>
<p>简单列出Java面试图谱，仅供参考！</p>
</blockquote>
<img src="/images/Java开发知识储备.png" width="90%">
<a id="more"></a>]]></content>
      <categories>
        <category>Java面试图谱</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
        <tag>图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>DOS攻击</title>
    <url>/2020/06/13/net-dos/</url>
    <content><![CDATA[<h3 id="什么是DOS攻击"><a href="#什么是DOS攻击" class="headerlink" title="什么是DOS攻击"></a><a href="https://baike.baidu.com/item/dos%E6%94%BB%E5%87%BB/3792374?fr=aladdin" target="_blank" rel="noopener">什么是DOS攻击</a></h3><blockquote>
<p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>说白了就是机器单挑，比谁的机器性能好、速度快<br>但是这种方式已经很远古了，毕竟计算机在迅速发展，性能也在不断提升，比如一个黑客用自己的机器，每秒钟发送10个伪装的数据包，但是被攻击的网站背后有十几台机器，每秒可以接受成百上千的数据，这时候攻击就无济于事了，反而会偷鸡不成蚀把米，自己的机器很可能会宕机。</p>
</blockquote>
<h3 id="什么是DDOS"><a href="#什么是DDOS" class="headerlink" title="什么是DDOS"></a>什么是DDOS</h3><blockquote>
<p>分布式拒绝服务攻击，简单说就是群殴，技术在发展，黑客也在学习，ddos就是黑客利用多台 “<strong>肉鸡</strong>”（就是可以被远程控制的多台机器），对某一网站进行攻击，可能每台机器每秒发送10个数据包，成群的 <strong>肉鸡</strong> 便可以每秒钟发出成百上千的伪装的攻击数据包，这个时候就很难抵挡了。到目前为止，防止这种攻击还是很吃力的。</p>
</blockquote>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><blockquote>
<p>我们了解了什么事dos，什么事ddos, 那么他们是怎么攻击的呢，原理是什么？？？<br>按照原理，简单来说以下几种：<br> 1.比如IP为1.1.1.1的地址是合法用户，黑客可以把自己的IP伪装成1.1.1.1，向服务器发送一个带有RST位的TCP数据段，服务器接收到之后认为该链接有错误，便会清除缓冲区建立好的连接，这时合法用户再去访问只能重新建立连接。<br> 2.向服务器发送大量的毫无用处的UDP数据包，占满带宽，导致网络可用带宽占满，最终导致服务器瘫痪。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>网络</tag>
        <tag>dos</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手、四次挥手</title>
    <url>/2020/06/14/net-three-and-four/</url>
    <content><![CDATA[<blockquote>
<h6 id="过程如下图"><a href="#过程如下图" class="headerlink" title="过程如下图"></a>过程如下图</h6></blockquote>
<img src="/images/threeAndFour.png" width="80%">
<a id="more"></a>

<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote>
<p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，客户端和服务器端是相对的概念，本文我们以客户端向服务器端发送为例。</p>
</blockquote>
<blockquote>
<p><strong>第一次握手：客户端向服务器端发送一个SYN报文，报文中包含了一个动态生成的序列号i（至于为什么动态生成可以自己想想），这时，客户端处于SYN_SEND状态（打开一个连接），表示已向服务器发送了连接请求；</strong></p>
</blockquote>
<blockquote>
<p><strong>第二次握手：服务器端接收到连接请求，认为可以建起连接，回发一个ACK确认报文，内容将序列号i+1,同时，生成一个序列号j，发送一个SYN报文，内容为序列号j，服务器端处于SYN_REVD状态（连接请求已到达，等待确认），表示等待客户端确认连接；</strong></p>
</blockquote>
<blockquote>
<p><strong>第三次握手：客户端接收到服务器端的反馈，立马发送一个ACK报文，内容为j+1，便是确认连接，这时客户端状态为establish(正常传输状态)</strong></p>
</blockquote>
<blockquote>
<p><strong>服务器端接收到ACK报文后，连接建立完成。</strong></p>
</blockquote>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>依然以客户端主动发起断开连接为例。</p>
<blockquote>
<p><strong>第一次挥手：客户端主动发起断开请求，动态生成一个序列号M，向服务器发送一个FIN报文，此时，客户端处于FIN_WAIT1状态；</strong></p>
</blockquote>
<blockquote>
<p><strong>第二次挥手： 服务器端收到客户端的断开请求，发送确认报文ACK(M+1)，告诉客户端，我知道了，等我处理完这波数据，此时服务器状态为CLOSE_WAIT;</strong></p>
</blockquote>
<blockquote>
<p><strong>第三次挥手： 等服务器处理完，准备要断开连接了，向客户端发送一个FIN报文，伴有动态生成的序列号N，此时服务器状态LAST_ACK;</strong></p>
</blockquote>
<blockquote>
<p><strong>第四次挥手： 客户端收到服务器发来的断开连接报文，则回复一个ACK报文N+1，表示我确认断开连接，这时客户端处于</strong> <strong><em>TIME_WAIT状态</em></strong> <strong>，很关键的状态，面试高频出现；</strong></p>
</blockquote>
<blockquote>
<p><strong>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</strong></p>
</blockquote>
<h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><ol>
<li><p><strong>TIME_WAIT状态</strong></p>
<pre><code>为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，
要确保服务器是否已经收到了我们的 ACK 报文，
如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。
至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功收到 ACK 报文，此时处于 CLOSED 状态。</code></pre></li>
<li><p><strong>半连接</strong><br>  <strong>即发送了SYN包还未收到ACK确认包的连接状态为半连接状态，还未完成三次握手TCP连接。</strong></p>
<pre><code>半连接队列:在三次握手协议中，服务器维护一个半连接队列；
该队列为每个客户端的SYN包(SYN=i)开设一个条目，
该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。
这些条目所标识的连接在服务器处于SYN_ RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</code></pre></li>
<li><p><strong>DOS攻击</strong></p>
<pre><code>因为服务器会维护一个半连接的队列，那如果我们向服务器发送大量伪造的无效的半连接请求，便会消耗cpu和内存，
当伪造的SYN包长时间占用半连接队列，正常的SYN请求遍会被抛弃，服务器便面临着网络阻塞甚至系统瘫痪的风险，
这也是比较常见的一种DOS攻击方式。</code></pre></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>internet</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络分层</title>
    <url>/2020/06/20/net-OSI/</url>
    <content><![CDATA[<p>本文简单介绍一下两种分层模型：OSI网络分层和TCP/IP网络分层。</p>
<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><blockquote>
<p>OSI模型一共分为七层，由上至下分别是：</p>
</blockquote>
<ul>
<li>应用层</li>
<li>表达层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层<a id="more"></a>

</li>
</ul>
<h4 id="应用层-Application"><a href="#应用层-Application" class="headerlink" title="应用层(Application)"></a>应用层(Application)</h4><pre><code>应用层的协议一般有：HTTP、FTP、DNS等，这一层是最接近用户的一层。</code></pre><h4 id="表达层-Presentation"><a href="#表达层-Presentation" class="headerlink" title="表达层(Presentation)"></a>表达层(Presentation)</h4><pre><code>该层的主要功能：转换，压缩和加密，常见的加密协议为SSL。</code></pre><h4 id="会话层-Session"><a href="#会话层-Session" class="headerlink" title="会话层(Session)"></a>会话层(Session)</h4><pre><code>我们可以把会话层理解为两个应用进程之间的逻辑连接，同时会话层还负责了管理和确定传输模式
计算机传输数据有三种模式：单向、半双工、全双工</code></pre><h4 id="传输层-Transport"><a href="#传输层-Transport" class="headerlink" title="传输层(Transport)"></a>传输层(Transport)</h4><pre><code>传输层就是表面意思传输了，端到端，主机到主机的传输
这一层最主要的就是TCP、UDP啦，包括三次握手、四次挥手是必须要会的</code></pre><h4 id="网络层-Network"><a href="#网络层-Network" class="headerlink" title="网络层(Network)"></a>网络层(Network)</h4><pre><code>网络层需要提供三个最基本的功能：地址、路由、分段和重组
网络层上最重要的协议IP（Internet Protocol），就是为了这些功能而设计的。目前有IPv4和IPv6两个版本。</code></pre><h4 id="数据链路层-Data-Link"><a href="#数据链路层-Data-Link" class="headerlink" title="数据链路层(Data Link)"></a>数据链路层(Data Link)</h4><pre><code>数据链路层又分为两个子层：逻辑链路控制层(Logical Link Control)和介质访问控制层(Media Access Control)
数据链路层就是关心如何把数据从一个设备发送到另一个设备</code></pre><h4 id="物理层-Physical"><a href="#物理层-Physical" class="headerlink" title="物理层(Physical)"></a>物理层(Physical)</h4><pre><code>物理层位于OSI的底层，所有其他层的数据最终都必须经由物理层才能发送出去。</code></pre><hr>
<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><pre><code>TCP/IP模型分为四层：应用层（Application）、传输层（Host-to-Host Transport）、互联网层(Internet)、网络接口层(Network Interface)。</code></pre><p>在TCP/IP模型中并不包含物理层。另外，两个重要的协议ARP（Address Resolution Protocol，地址解析协议）和RARP（Reverse Address Resolution Protocol，反向地址转换协议），在OSI模型中一般被认为是在位于第二层数据链路层和第三层网络层之间，而在TCP/IP模型中则位于网络接口层。(此段转载自掘金：<a href="https://juejin.im/post/5a98e1f7f265da237410694e" target="_blank" rel="noopener">https://juejin.im/post/5a98e1f7f265da237410694e</a> 作者：MinGRn）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021届校招内推分享</title>
    <url>/2020/05/08/java-push/</url>
    <content><![CDATA[<blockquote>
<p>分享几个2021届校招内推信息，持续更新</p>
</blockquote>
<ul>
<li>快手21届校招内推，直接申请投递即可<br><a href="https://campus.kuaishou.cn/recruit/campus/e/#/campus/jobs?internalPerson=TkttKFlRkBS2hYdhonMHuw%3D%3D&amp;recruitSubProjectCode=2021qiuzhao" target="_blank" rel="noopener">https://campus.kuaishou.cn/recruit/campus/e/#/campus/jobs?internalPerson=TkttKFlRkBS2hYdhonMHuw%3D%3D&amp;recruitSubProjectCode=2021qiuzhao</a><a id="more"></a>
</li>
</ul>
<hr>
<ul>
<li>字节跳动内推，直接申请<img src="/images/tiktok.jpg" width="30%" height="30%">
</li>
</ul>
<hr>
<ul>
<li>贝壳Java开发内推，岗位信息如下，内推添加微信发送简历 微信：m1159950461(添加请实名说明原因)<br>  <a href="http://campus.ke.com/zpdetail/190239336?k=java&amp;r=-1&amp;d=&amp;c=&amp;p=" target="_blank" rel="noopener">http://campus.ke.com/zpdetail/190239336?k=java&amp;r=-1&amp;d=&amp;c=&amp;p=</a></li>
</ul>
<hr>
<ul>
<li>滴滴内推<img src="/images/didi.jpg" width="30%" height="30%">

</li>
</ul>
]]></content>
      <categories>
        <category>内推</category>
      </categories>
      <tags>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端开发面试大纲(校招)</title>
    <url>/2022/05/16/interview-college/</url>
    <content><![CDATA[<h1 id="服务端开发校招面试大纲"><a href="#服务端开发校招面试大纲" class="headerlink" title="服务端开发校招面试大纲"></a>服务端开发校招面试大纲</h1><blockquote>
<p>秋招在即，送给后端开发的校招生们，持续补充。。。</p>
</blockquote>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><strong>计算机基础</strong></h2><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a><strong>数据结构与算法</strong></h3><blockquote>
<p>即使这两个东西在学校的课程中，可能是分开教授，但是在面试上数据结构与算法是分不开的，数据结构是算法的基础，算法是数据结构的表达</p>
</blockquote>
<ul>
<li><strong>数据结构</strong><ul>
<li><strong>数组</strong></li>
<li><strong>链表</strong><a id="more"></a></li>
<li><strong>堆栈</strong></li>
<li><strong>队列</strong></li>
<li><strong>树</strong><ul>
<li><strong>二叉树</strong><blockquote>
<p>面试算法中出现频率很高，前序中序后序遍历，左旋右旋，倒置，二叉树合并等等</p>
</blockquote>
</li>
<li><strong>B/B+树</strong><blockquote>
<p>面试中，往往在mysql中的索引会问到</p>
</blockquote>
</li>
<li><strong>红黑树</strong><blockquote>
<p>编码难度较大，做到了解就够</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>图</strong><blockquote>
<p>面试问到的相对较少</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>算法</strong><ul>
<li><strong>没有捷径，刷题！</strong><blockquote>
<p>数据结构是基础，打好基础的前提下，做题可以促进对算法的理解</p>
</blockquote>
</li>
<li><strong>刷题推荐 <a href="https://leetcode.cn/problemset/all/" target="_blank" rel="noopener">leetcode</a></strong><blockquote>
<p>每一道题最好思考一下，时间复杂度和空间复杂度以及最优解</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h3><ul>
<li><strong>基本概念</strong><ul>
<li>七层网络协议</li>
</ul>
</li>
<li><strong>网络层</strong><ul>
<li>ipv4</li>
<li>ipv6</li>
</ul>
</li>
<li><strong>传输层</strong><ul>
<li>TCP</li>
<li>UDP</li>
<li>三次握手 四次挥手<blockquote>
<p><em>过程越详细越好</em></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>应用层</strong><ul>
<li>http/https</li>
<li>http1.0 http2.0</li>
<li>post/get</li>
<li>header</li>
<li>keep-alive</li>
<li>cookie/session</li>
</ul>
</li>
</ul>
<h3 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a><strong>计算机操作系统</strong></h3><ul>
<li>进程与线程<ul>
<li>区别与联系</li>
<li>原子操作</li>
<li>volatile<blockquote>
<p>指令重排序</p>
</blockquote>
</li>
</ul>
</li>
<li>锁<ul>
<li>读写锁</li>
<li>互斥锁</li>
<li>循环锁</li>
<li>死锁</li>
</ul>
</li>
<li>内存管理<ul>
<li>堆</li>
<li>栈</li>
</ul>
</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><ul>
<li>SQL语句<blockquote>
<p>结合实际场景，写一个sql</p>
</blockquote>
</li>
<li>索引<blockquote>
<p>要深入了解索引的实现原理，譬如innoDB的索引是怎么实现的，B+树是什么样子的，以及为什么联合索引只能最左匹配</p>
</blockquote>
<ul>
<li>聚簇索引</li>
<li>非聚簇索引</li>
<li>唯一索引</li>
<li>组合索引</li>
<li>主键</li>
</ul>
</li>
<li>事务</li>
<li>存储引擎</li>
<li>范式</li>
<li>CAP原理</li>
<li>Mysql、MongoDB、RocksDB等，关系型数据库至少用过其一，最好能说出来遇到过的问题如何解决的</li>
</ul>
<h2 id="开发语言（至少熟练其一）"><a href="#开发语言（至少熟练其一）" class="headerlink" title="开发语言（至少熟练其一）"></a>开发语言（至少熟练其一）</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><blockquote>
<p>目前还是Java的市场比较大，学校里学的最多的面向对象语言，同时竞争也很大，语言本省需要掌握的深度也要很深入，如果想要出类拔萃，最好研究源码，仅仅会用是不够的</p>
</blockquote>
<h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a><strong>Golang</strong></h3><blockquote>
<p>最近几年比较流行的语言，门槛低，上手很快，可以说语法3天就能学会上手，市场不如Java广，但是竞争比Java低，特点是快</p>
</blockquote>
<h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a><strong>C/C++</strong></h3><blockquote>
<p>个人认为C++是最难的语言，首先语法是所有语言最复杂的，尤其在内存管理上，需要程序员有一个很好的编码习惯</p>
</blockquote>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><blockquote>
<p>更多的使用在机器学习领域、自动化测试等，个人涉及不多，不妄下结论</p>
</blockquote>
<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><strong>Rust</strong></h3><blockquote>
<p>算是一门新兴语言，目前更多的被运用在客户端开发等项目中，作为C++的替代品正在被更多的程序员所学习和接受，如果同学手持C++利剑，不妨来看看它</p>
</blockquote>
<h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3><blockquote>
<p>迄今为止，开发语言种类越来越多，有被大众熟知的Python、C/C++、Java等，也有不被人知晓的Q、Lua等等，每种语言都是一杆“枪”，尽管每种语言都有各自的优缺点，但是个人认为，语言不是那么的重要，工作中大都是在不同的背景下选择合适的语言或者基于项目的架构设计我们也没有选择。所以，对于大学生而言，选一门自己喜欢的语言学习就好，从入门到放弃，从放弃到捡起，从捡起到剖析，一直下去。。。</p>
</blockquote>
<h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h2><h3 id="学校大作业"><a href="#学校大作业" class="headerlink" title="学校大作业"></a><strong>学校大作业</strong></h3><blockquote>
<p>要有质量的，不要很粗糙的东西，譬如 “基于C语言实现的学生信息管理系统” 就没必要写了</p>
</blockquote>
<h3 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a><strong>实习项目</strong></h3><blockquote>
<p>在不违背老东家的规定前提下，可以多润色，毕竟企业的项目对于大学生来说是很难得的</p>
</blockquote>
<h3 id="自研项目"><a href="#自研项目" class="headerlink" title="自研项目"></a><strong>自研项目</strong></h3><blockquote>
<p>如果有自己的小项目，或者有自己的开源代码，小露一手还是很加分的</p>
</blockquote>
<h2 id="应该会的"><a href="#应该会的" class="headerlink" title="应该会的"></a>应该会的</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><blockquote>
<p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
</blockquote>
<ul>
<li>git add</li>
<li>git comment</li>
<li>git push</li>
<li>git merge</li>
<li>git rebase</li>
<li>git reset</li>
<li>git checkout</li>
<li>git branch</li>
<li>git stash</li>
<li>git cherry-pick </li>
<li>…..</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h3><ul>
<li>ls、cd、cp、rm、mv、touch、mkdir、cat、less、sudo、grep等基本命令</li>
<li>基本目录结构</li>
<li>简单的shell脚本<blockquote>
<p>可以不会复杂的shell，但是要保证基本的shell可以看的懂</p>
</blockquote>
</li>
</ul>
<h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a><strong>自我介绍</strong></h3><blockquote>
<p>姓名、联系方式，身高体重就没必要写了</p>
</blockquote>
<h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a><strong>教育背景</strong></h3><blockquote>
<p>如果四六级考过了，而且分数很高，可以把分数写上</p>
</blockquote>
<h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a><strong>专业技能</strong></h3><blockquote>
<p>这个很重要，面试官一般会围绕这个来作为考察点，不会的或者不了解的一定不要乱写，容易撞枪口上</p>
</blockquote>
<h3 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a><strong>实习经历</strong></h3><blockquote>
<p>校招生如果有一个好的实习经历，是个加分项</p>
</blockquote>
<h3 id="项目经验-1"><a href="#项目经验-1" class="headerlink" title="项目经验"></a><strong>项目经验</strong></h3><h3 id="校园履历-成就"><a href="#校园履历-成就" class="headerlink" title="校园履历/成就"></a><strong>校园履历/成就</strong></h3><hr>
<blockquote>
<p><strong>附件：</strong></p>
</blockquote>
<p><img src="/images/interview_summary.jpeg" alt="大纲" title="大纲"></p>
]]></content>
      <categories>
        <category>面试大纲</category>
      </categories>
      <tags>
        <tag>校招</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端校招知识点一 数据结构之数组</title>
    <url>/2022/05/15/data-structure-array/</url>
    <content><![CDATA[<h2 id="鸡汤"><a href="#鸡汤" class="headerlink" title="鸡汤"></a>鸡汤</h2><blockquote>
<p>人生没有连续的一帆风顺，总是要靠自己的坚持来维护这一份延续<br>一段连续的快乐总是那么不容易被插入或打断</p>
</blockquote>
<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在复习数据之前，我们先回忆一个概念，什么是线性表，线性表和数组的关系是什么？接下来让我们一起来回顾一下</p>
<h2 id="2、线性表"><a href="#2、线性表" class="headerlink" title="2、线性表"></a>2、线性表</h2><p>定义：<strong>零个或多个数据元素组成的有限序列。</strong><br>解释：我们注意定义中有两个点，一个是数据元素，一个是有限序列。首先线性表是一个序列，强调这个序列是有限长度n，其中<strong>n≥0</strong>, n=0的序列我们成为空表；数据元素则是一个抽象的概念，数据元素可能是数字1、2、3，可能是猴、狗等动物，也可能是本子、笔等文具。</p>
<h2 id="3、数组与线性表的关系"><a href="#3、数组与线性表的关系" class="headerlink" title="3、数组与线性表的关系"></a>3、数组与线性表的关系</h2><a id="more"></a>
<p>数据是线性表的顺序存储结构，即用一段连续的存储单元一次存储线性表的数据元素。有两个概念我们要区分一下，“数组的长度”和“线性表的长度”是有区别的，一般来说，数组的长度要大于等于线性表的长度，简单可以理解为我们在一些高级语言中看到的长度（len）和容量（cap），数组是存储线性表的存储空间，已经分配的存储空间一般是不会变的。当然一些高级语言中会通过某些编程的手段使数组实现动态分配，但这是很消耗的，所以在我们日常的开发中，都会尽量避免数组的重新分配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如已知arr1数组长度，需要申请一个和arr1相同长度的数据</span></span><br><span class="line">arr2 := <span class="built_in">make</span>([]<span class="keyword">int64</span>, <span class="built_in">len</span>(arr1)) <span class="comment">// 作为伪代码理解</span></span><br></pre></td></tr></table></figure>

<h2 id="4、数组的地址计算"><a href="#4、数组的地址计算" class="headerlink" title="4、数组的地址计算"></a>4、数组的地址计算</h2><p>由于数组是顺序存储的，所以数组的地址也就是连续的一段空间，我们在编程语言中的往往定义起始地址是0，这有悖于我们从小接受的从1开始数数的教育。于是线性表的第i个元素在顺序存储结构中的位置应该是i - 1，即数据元素的序列号与存储的位置如下图<br><img src="/images/array_index.png" width="90%"></p>
<h2 id="5、数组的插入与删除"><a href="#5、数组的插入与删除" class="headerlink" title="5、数组的插入与删除"></a>5、数组的插入与删除</h2><h3 id="5-1-数据元素检索"><a href="#5-1-数据元素检索" class="headerlink" title="5.1 数据元素检索"></a>5.1 数据元素检索</h3><p>对于顺序存储结构来说，获取某一个位置的元素是很容易的，譬如，我们要获取第i个元素，我们只需要将第i-1位置的元素去除即可，这里的时间复杂度为<strong>O(1)</strong>。</p>
<h3 id="5-2-数据元素插入"><a href="#5-2-数据元素插入" class="headerlink" title="5.2 数据元素插入"></a>5.2 数据元素插入</h3><p>上面我们说到了，从数组中取一个位置的数据是很容易的，那么插入呢？我们可以想象一下，在课堂的一排座位是一个数组，那么现在新来一位同学，他要选择这一排的某个位置上，我们都要怎么做呢，首先这位新同学要选的位置是符合老师的期望的，然后要看这一排的座位是否足够容纳这位新同学，如果不够，我们就要搬来一个座位来满足需求，假如新同学选的是第i个位置，那么为了保持这一排的其他同学顺序不变，只能从最后一位同学开始到第i个同学，依次向后移动一个位置，空出来的新第i位置留给新同学。由此我们知道，将一个数据元素插入数组，我们需要做这些事：</p>
<ul>
<li>判断要插入的位置是否合理，不合理抛出异常</li>
<li>如果插入后的数据元素个数大于数组长度，那么就需要返回异常或者动态申请新的存储空间</li>
<li>从最后一个数据元素开始，到第i位置的元素，依次向后移动一个存储单元</li>
<li>第i位置赋值为要插入的元素<pre><code>// 代码过于简单，忽略</code></pre></li>
</ul>
<h3 id="5-3-数据元素删除"><a href="#5-3-数据元素删除" class="headerlink" title="5.3 数据元素删除"></a>5.3 数据元素删除</h3><p>同插入的场景中提到的，那么删除的过程自然就是插入的逆序，还用刚才的例子，假如这个新来的同学在第i位置坐的很不爽，前后的同学总是合谋欺负他，那么他要离开这个位置换到其他排，那么从第i+1位置开始，都需要依次向前移动一个位置，并将最后一个位置元素清除（线性表长度减1）</p>
<ul>
<li>判断要删除的位置是否合理，不合理抛出异常</li>
<li>从第i+1个数据元素到最后一个数据元素，依次向前移动一个存储单元</li>
<li>线性表长度减1</li>
</ul>
<h2 id="6、数组的优劣势"><a href="#6、数组的优劣势" class="headerlink" title="6、数组的优劣势"></a>6、数组的优劣势</h2><blockquote>
<p>优势：</p>
</blockquote>
<ul>
<li>快速获取线性表中的任意位置数据元素</li>
<li>数据元素顺序存储，不需要维护数据元素之间的关联关系（利用物理内存位置维护，地址依次递增）</li>
</ul>
<blockquote>
<p>劣势：</p>
</blockquote>
<ul>
<li>插入和删除操作需要移动线性表中的大多数数据元素</li>
<li>线性表长度大于分配的存储空间时，需要重新申请存储空间，性能有比较大的消耗</li>
<li>存储空间连续，当线性表的长度很大是，内存分配是个问题</li>
</ul>
]]></content>
      <categories>
        <category>校招面试</category>
      </categories>
      <tags>
        <tag>校招</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
